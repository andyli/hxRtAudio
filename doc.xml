<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/cpp/_std/Hash.hx">
		<toString public="1" set="method" line="76">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="61">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="45">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="41">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="37">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="33">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<__Internal><d/></__Internal>
		<new public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="33" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="42" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="46" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="51" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="58" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="65" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="69" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="73" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="81" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="88" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="93" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="104" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cpp/_std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addChar public="1" get="inline" set="null" line="43">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="39">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<add public="1" get="inline" set="null" line="35">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="44" static="1">
			<f a="lib:prim:nargs">
				<unknown/>
				<unknown/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="60" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="62" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="67" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="75" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="89" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="32" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<stdin public="1" set="method" line="37" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="41" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="45" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<getChar public="1" set="method" line="49" static="1">
			<f a="echo">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<args public="1" set="method" line="53" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="57" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="64" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="68" static="1">
			<f a="seconds">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="72" static="1">
			<f a="loc">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="76" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="84" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<escapeArgument set="method" line="88" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="102" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="111" static="1">
			<f a="code">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="115" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="119" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="123" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<environment public="1" set="method" line="127" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env line="138" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="139" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="140" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="141" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="142" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="143" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="144" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="145" static="1"><f a="">
	<c path="String"/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="146" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="147" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="148" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="149" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="150" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
		<file_stdin line="152" static="1"><f a=""><unknown/></f></file_stdin>
		<file_stdout line="153" static="1"><f a=""><unknown/></f></file_stdout>
		<file_stderr line="154" static="1"><f a=""><unknown/></f></file_stderr>
		<getch line="156" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="39" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="50" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="60" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="66" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="84" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="90" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="94" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="100" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="106" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="110" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="114" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="118" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="134" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="138" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="142" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="147" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="151" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<typedef path="cpp.vm.ThreadHandle" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx" module="cpp.vm.Thread"><d/></typedef>
	<class path="cpp.vm.Thread" params="" file="/usr/lib/haxe/std/cpp/vm/Thread.hx">
		<current public="1" set="method" line="48" static="1">
			<f a=""><c path="cpp.vm.Thread"/></f>
			<haxe_doc>Returns the current thread.</haxe_doc>
		</current>
		<create public="1" set="method" line="55" static="1">
			<f a="callb">
				<f a=""><e path="Void"/></f>
				<c path="cpp.vm.Thread"/>
			</f>
			<haxe_doc>Creates a new thread that will execute the [callb] function, then exit.</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="64" static="1">
			<f a="block">
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.</haxe_doc>
		</readMessage>
		<__compare set="method" line="68"><f a="t">
	<a><handle set="null"><t path="cpp.vm.ThreadHandle"/></handle></a>
	<c path="Int"/>
</f></__compare>
		<sendMessage public="1" set="method" line="40">
			<f a="msg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Send a message to the thread queue. This message can be readed by using [readMessage].</haxe_doc>
		</sendMessage>
		<handle public="1" set="null"><t path="cpp.vm.ThreadHandle"/></handle>
		<new set="method" line="33"><f a="h">
	<t path="cpp.vm.ThreadHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Int32" params="" file="/usr/lib/haxe/std/cpp/_std/haxe/Int32.hx" extern="1">
		<make public="1" set="method" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" set="method" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" set="method" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<add public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<isNeg public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<ucompare public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></ucompare>
		<toNativeInt public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<meta><m n=":native"><e>cpp.CppInt32__</e></m></meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="126">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<addBytes public="1" get="inline" set="null" line="100"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<add public="1" get="inline" set="null" line="81"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addByte public="1" get="inline" set="null" line="63"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<_float_of_bytes line="425" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="426" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<readString public="1" set="method" line="408"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="393"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readUInt30 public="1" set="method" line="384"><f a=""><c path="Int"/></f></readUInt30>
		<readInt31 public="1" set="method" line="367"><f a=""><c path="Int"/></f></readInt31>
		<readUInt24 public="1" set="method" line="360"><f a=""><c path="Int"/></f></readUInt24>
		<readInt24 public="1" set="method" line="350"><f a=""><c path="Int"/></f></readInt24>
		<readUInt16 public="1" set="method" line="344"><f a=""><c path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="335"><f a=""><c path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="328"><f a=""><c path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="255"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="201"><f a=""><c path="Float"/></f></readFloat>
		<readLine public="1" set="method" line="184"><f a=""><c path="String"/></f></readLine>
		<readUntil public="1" set="method" line="176"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<read public="1" set="method" line="164"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="156"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<readAll public="1" set="method" line="80"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<setEndian set="method" line="73"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="70"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="49"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="40"><f a=""><c path="Int"/></f></readByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<LN2 line="34" static="1"><c path="Float"/></LN2>
		<_float_bytes line="364" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="365" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<writeString public="1" set="method" line="348"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<writeInput public="1" set="method" line="326"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<prepare public="1" set="method" line="323">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInt32 public="1" set="method" line="303"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<writeUInt30 public="1" set="method" line="288"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt31 public="1" set="method" line="271"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt24 public="1" set="method" line="258"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt24 public="1" set="method" line="253"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt16 public="1" set="method" line="242"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="237"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="231"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="154"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="100"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeFullBytes public="1" set="method" line="92"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<write public="1" set="method" line="81"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<setEndian set="method" line="74"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="71"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="68"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="45"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="41"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<enum path="rtAudio.Api" params="" file="src/rtAudio/Api.hx">
		<WINDOWS_DS><haxe_doc>* The Microsoft Direct Sound API.</haxe_doc></WINDOWS_DS>
		<WINDOWS_ASIO><haxe_doc>* The Steinberg Audio Stream I/O API.</haxe_doc></WINDOWS_ASIO>
		<UNSPECIFIED><haxe_doc>* Search for a working compiled API.</haxe_doc></UNSPECIFIED>
		<UNIX_JACK><haxe_doc>* The Jack Low-Latency Audio Server API.</haxe_doc></UNIX_JACK>
		<RTAUDIO_DUMMY><haxe_doc>* A compilable but non-functional API.</haxe_doc></RTAUDIO_DUMMY>
		<MACOSX_CORE><haxe_doc>* Macintosh OS-X Core Audio API.</haxe_doc></MACOSX_CORE>
		<LINUX_OSS><haxe_doc>* The Linux Open Sound System API.</haxe_doc></LINUX_OSS>
		<LINUX_ALSA><haxe_doc>* The Advanced Linux Sound Architecture API.</haxe_doc></LINUX_ALSA>
		<haxe_doc>* Audio API specifier.</haxe_doc>
	</enum>
	<typedef path="rtAudio.DeviceInfo" params="" file="src/rtAudio/DeviceInfo.hx">
		<a>
			<sampleRates>
				<c path="Array"><c path="Int"/></c>
				<haxe_doc>* Supported sample rates (queried from list of standard rates).</haxe_doc>
			</sampleRates>
			<probed><e path="Bool"/></probed>
			<outputChannels>
				<c path="Int"/>
				<haxe_doc>* Maximum output channels supported by device.</haxe_doc>
			</outputChannels>
			<nativeFormats>
				<c path="Array"><e path="rtAudio.RtAudioFormat"/></c>
				<haxe_doc>* Array of supported data formats.</haxe_doc>
			</nativeFormats>
			<name>
				<c path="String"/>
				<haxe_doc>* Device identifier.</haxe_doc>
			</name>
			<isDefaultOutput>
				<e path="Bool"/>
				<haxe_doc>* true if this is the default output device.</haxe_doc>
			</isDefaultOutput>
			<isDefaultInput>
				<e path="Bool"/>
				<haxe_doc>* true if this is the default input device.</haxe_doc>
			</isDefaultInput>
			<inputChannels>
				<c path="Int"/>
				<haxe_doc>* Maximum input channels supported by device.</haxe_doc>
			</inputChannels>
			<duplexChannels>
				<c path="Int"/>
				<haxe_doc>* Maximum simultaneous input/output channels supported by device.</haxe_doc>
			</duplexChannels>
		</a>
		<haxe_doc>* The public device information structure for returning queried values.</haxe_doc>
	</typedef>
	<class path="rtAudio.RtAudio" params="" file="src/rtAudio/RtAudio.hx">
		<getCompiledApi public="1" set="method" line="49" static="1">
			<f a=""><c path="Array"><e path="rtAudio.Api"/></c></f>
			<haxe_doc>* A static function to determine the available compiled audio APIs.
	 * 
	 * @return Array of compiled Api.</haxe_doc>
		</getCompiledApi>
		<_RtAudio_getCompiledApi line="507" static="1"><f a=""><c path="Array"><d/></c></f></_RtAudio_getCompiledApi>
		<_RtAudio_new line="508" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></_RtAudio_new>
		<_RtAudio_getCurrentApi line="509" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getCurrentApi>
		<_RtAudio_getDeviceCount line="510" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getDeviceCount>
		<_RtAudio_getDeviceInfo line="511" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></_RtAudio_getDeviceInfo>
		<_RtAudio_getDefaultOutputDevice line="512" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getDefaultOutputDevice>
		<_RtAudio_getDefaultInputDevice line="513" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getDefaultInputDevice>
		<_RtAudio_closeStream line="514" static="1"><f a="">
	<d/>
	<unknown/>
</f></_RtAudio_closeStream>
		<_RtAudio_startStream line="515" static="1"><f a="">
	<d/>
	<unknown/>
</f></_RtAudio_startStream>
		<_RtAudio_stopStream line="516" static="1"><f a="">
	<d/>
	<unknown/>
</f></_RtAudio_stopStream>
		<_RtAudio_abortStream line="517" static="1"><f a="">
	<d/>
	<unknown/>
</f></_RtAudio_abortStream>
		<_RtAudio_isStreamOpen line="518" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></_RtAudio_isStreamOpen>
		<_RtAudio_isStreamRunning line="519" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></_RtAudio_isStreamRunning>
		<_RtAudio_getStreamTime line="520" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></_RtAudio_getStreamTime>
		<_RtAudio_getStreamLatency line="521" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getStreamLatency>
		<_RtAudio_getStreamSampleRate line="522" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_RtAudio_getStreamSampleRate>
		<_RtAudio_showWarnings line="523" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></_RtAudio_showWarnings>
		<_RtAudio_openStream line="524" static="1"><f a="::">
	<d/>
	<c path="rtAudio.RtAudio"/>
	<a>
		<userData><d/></userData>
		<sampleRate><c path="Int"/></sampleRate>
		<outputParameters><t path="Null"><t path="rtAudio.StreamParameters"/></t></outputParameters>
		<options><d/></options>
		<inputParameters><t path="Null"><t path="rtAudio.StreamParameters"/></t></inputParameters>
		<format><d/></format>
		<bufferFrames><c path="Int"/></bufferFrames>
	</a>
	<unknown/>
</f></_RtAudio_openStream>
		<_RtAudio_waitForSoundData line="525" static="1"><f a="">
	<c path="rtAudio.RtAudio"/>
	<unknown/>
</f></_RtAudio_waitForSoundData>
		<_RtAudio_setReady line="526" static="1"><f a="">
	<c path="rtAudio.RtAudio"/>
	<unknown/>
</f></_RtAudio_setReady>
		<threadFunc set="method" line="493">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Function for the thread.</haxe_doc>
		</threadFunc>
		<lastStreamCallBackResult>
			<d/>
			<haxe_doc>* The reture value of streamCallback is stored here temporary.</haxe_doc>
		</lastStreamCallBackResult>
		<thread>
			<c path="cpp.vm.Thread"/>
			<haxe_doc>* The Thread created to call streamCallback when needed.</haxe_doc>
		</thread>
		<semaphoreReady><d/></semaphoreReady>
		<semaphoreWait><d/></semaphoreWait>
		<inputBuffer public="1" set="null">
			<d/>
			<haxe_doc><![CDATA[* Buffer for storing the input stream data, that used by streamCallback.
	 * You should cast it to Array<Int> or Array<Float> depending on the format you specified.]]></haxe_doc>
		</inputBuffer>
		<outputBuffer public="1" set="null">
			<d/>
			<haxe_doc><![CDATA[* Buffer that needs to be filled by streamCallback when playing a output stream.
	 * You should cast it to Array<Int> or Array<Float> depending on the format you specified.]]></haxe_doc>
		</outputBuffer>
		<status public="1" set="null">
			<c path="Int"/>
			<haxe_doc>* Status of the stream.</haxe_doc>
		</status>
		<options public="1" set="null">
			<t path="Null"><t path="rtAudio.StreamOptions"/></t>
			<haxe_doc>* The options you provided when calling openStream() is stored here.</haxe_doc>
		</options>
		<userData public="1" set="null">
			<d/>
			<haxe_doc>* The userData you provided when calling openStream() is stored here.</haxe_doc>
		</userData>
		<bufferFrames public="1" set="null">
			<d/>
			<haxe_doc>* The bufferFrames you provided when calling openStream() is stored here.</haxe_doc>
		</bufferFrames>
		<sampleRate public="1" set="null">
			<d/>
			<haxe_doc>* The sampleRate you provided when calling openStream() is stored here.</haxe_doc>
		</sampleRate>
		<formatValue public="1" set="null">
			<d/>
			<haxe_doc>* The formatValue you provided when calling openStream() is stored here.</haxe_doc>
		</formatValue>
		<format public="1" set="null">
			<e path="rtAudio.RtAudioFormat"/>
			<haxe_doc>* The format you provided when calling openStream() is stored here.</haxe_doc>
		</format>
		<inputParameters public="1" set="null">
			<t path="Null"><t path="rtAudio.StreamParameters"/></t>
			<haxe_doc>* The inputParameters you provided when calling openStream() is stored here.</haxe_doc>
		</inputParameters>
		<outputParameters public="1" set="null">
			<t path="Null"><t path="rtAudio.StreamParameters"/></t>
			<haxe_doc>* The outputParameters you provided when calling openStream() is stored here.</haxe_doc>
		</outputParameters>
		<streamCallback public="1" set="null">
			<t path="rtAudio.RtAudioCallback"/>
			<haxe_doc>* The streamCallback you provided when calling openStream() is stored here.</haxe_doc>
		</streamCallback>
		<handle public="1" set="null">
			<d/>
			<haxe_doc>* This is the handle to the real RtAudio object in ndll. Don't use it unless you know what it means.</haxe_doc>
		</handle>
		<openStream public="1" set="method" line="301">
			<f a="outputParameters:inputParameters:format:sampleRate:bufferFrames:streamCallback:?userData:?options">
				<t path="Null"><t path="rtAudio.StreamParameters"/></t>
				<t path="Null"><t path="rtAudio.StreamParameters"/></t>
				<e path="rtAudio.RtAudioFormat"/>
				<c path="Int"/>
				<c path="Int"/>
				<t path="rtAudio.RtAudioCallback"/>
				<d/>
				<t path="rtAudio.StreamOptions"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* A public function for opening a stream with the specified parameters.
	 * 
	 * <p>An RtError (type = SYSTEM_ERROR) is printed to console if a stream 
	 * cannot be opened with the specified parameters or an error occurs 
	 * during processing.  An RtError (type = INVALID_USE) is printed to 
	 * console if any invalid device ID or channel number parameters are 
	 * specified.</p>
	 * 
	 * @param	outputParameters	Specifies output stream parameters to use when opening a stream,
	 * 								including a device ID, number of channels,
	 * 								and starting channel number.  For input-only streams, this
	 * 								argument should be null.  The device ID is an index value between
	 * 								0 and getDeviceCount() - 1.
	 * @param	inputParameters		Specifies input stream parameters to use when opening a stream,
	 * 								including a device ID, number of channels,
	 * 								and starting channel number.  For output-only streams, this
	 * 								argument should be null.  The device ID is an index value between
	 * 								0 and getDeviceCount() - 1.
	 * @param	format				An RtAudioFormat specifying the desired sample data format.
	 * @param	sampleRate			The desired sample rate (sample frames per second).
	 * @param	bufferFrames		Indicating the desired internal buffer size in sample frames.
	 * 								The actual value used by the device is assigned to the property 
	 * 								of the same name. A value of zero can be specified, in which case 
	 * 								the lowest allowable value is determined.
	 * @param	streamCallback		A client-defined function that will be invoked when input data is 
	 * 								available and/or output data is needed.
	 * @param	?userData			An optional pointer to data that can be accessed from the property
	 * 								of the same name.
	 * @param	?options			An optional pointer to a StreamOptions containing various global 
	 * 								stream options, including a Array of RtAudioStreamFlags and a 
	 * 								suggested number of stream buffers that can be used to control 
	 * 								stream latency. More buffers typically result in more robust 
	 * 								performance, though at a cost of greater latency.  If a value of 
	 * 								zero is specified, a system-specific median value is chosen. If the
	 * 								RTAUDIO_MINIMIZE_LATENCY flag bit is set, the lowest allowable value 
	 * 								is used. The actual value used is assigned to the property of the 
	 * 								same name. The parameter is API dependent.]]></haxe_doc>
		</openStream>
		<showWarnings public="1" set="method" line="258">
			<f a="?value">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specify whether warning messages should be printed to stderr.
	 * 
	 * @param	value true if warning messages should be printed to stderr.</haxe_doc>
		</showWarnings>
		<getStreamSampleRate public="1" set="method" line="249">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* On some systems, the sample rate used may be slightly different
	 * than that specified in the stream parameters.  If a stream is not
	 * open, an RtError (type = INVALID_USE) will be printed to console.
	 * 
	 * @return Actual sample rate in use by the stream.</haxe_doc>
		</getStreamSampleRate>
		<getStreamLatency public="1" set="method" line="238">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* The stream latency refers to delay in audio input and/or output
	 * caused by internal buffering by the audio system and/or hardware.
	 * For duplex streams, the returned value will represent the sum of
	 * the input and output latencies. If a stream is not open, an
	 * RtError (type = INVALID_USE) will be printed to console. If the 
	 * API does not report latency, the return value will be zero.
	 * 
	 * @return The internal stream latency in sample frames.</haxe_doc>
		</getStreamLatency>
		<getStreamTime public="1" set="method" line="224">
			<f a=""><c path="Float"/></f>
			<haxe_doc>* If a stream is not open, an RtError (type = INVALID_USE) will be printed to console.
	 * 
	 * @return The number of elapsed seconds since the stream was started.</haxe_doc>
		</getStreamTime>
		<isStreamRunning public="1" set="method" line="215">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* @return true if the stream is running and false if it is stopped or not open.</haxe_doc>
		</isStreamRunning>
		<isStreamOpen public="1" set="method" line="208">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* @return true if a stream is open and false if not.</haxe_doc>
		</isStreamOpen>
		<abortStream public="1" set="method" line="201">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Stop a stream, discarding any samples remaining in the input/output queue.
	 * 
	 * <p>An RtError (type = SYSTEM_ERROR) is printed to console if an error occurs
	 * during processing.  An RtError (type = INVALID_USE) is printed to console if a
	 * stream is not open.  A warning is issued if the stream is already
	 * stopped.</p>]]></haxe_doc>
		</abortStream>
		<stopStream public="1" set="method" line="189">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Stop a stream, allowing any samples remaining in the output queue to be played.
	 * 
	 * <p>An RtError (type = SYSTEM_ERROR) is printed to console if an error occurs
	 * during processing.  An RtError (type = INVALID_USE) is printed to console 
	 * if a stream is not open.  A warning is issued if the stream is already
	 * stopped.</p>]]></haxe_doc>
		</stopStream>
		<startStream public="1" set="method" line="177">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* A function that starts a stream.
	 * 
	 * <p>An RtError (type = SYSTEM_ERROR) is printed to console if an error 
	 * occurs during processing. An RtError (type = INVALID_USE) is printed 
	 * to console if a stream is not open. A warning is issued if the stream 
	 * is already running.</p>]]></haxe_doc>
		</startStream>
		<closeStream public="1" set="method" line="165">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* A function that closes a stream and frees any associated stream memory.
	 * 
	 * <p>If a stream is not open, this function issues a warning and
	 * returns (no exception is thrown).</p>]]></haxe_doc>
		</closeStream>
		<getDefaultInputDevice public="1" set="method" line="155">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* If the underlying audio API does not provide a "default
	 * device", or if no devices are available, the return value will be
	 * 0.  Note that this is a valid device identifier and it is the
	 * client's responsibility to verify that a device is available
	 * before attempting to open a stream.
	 * 
	 * @return The index of the default input device.</haxe_doc>
		</getDefaultInputDevice>
		<getDefaultOutputDevice public="1" set="method" line="142">
			<f a=""><c path="Int"/></f>
			<haxe_doc>* If the underlying audio API does not provide a "default
	 * device", or if no devices are available, the return value will be
	 * 0.  Note that this is a valid device identifier and it is the
	 * client's responsibility to verify that a device is available
	 * before attempting to open a stream.
	 * 
	 * @return The index of the default output device.</haxe_doc>
		</getDefaultOutputDevice>
		<getDeviceInfo public="1" set="method" line="107">
			<f a="device">
				<c path="Int"/>
				<t path="rtAudio.DeviceInfo"/>
			</f>
			<haxe_doc>* Any device integer between 0 and getDeviceCount() - 1 is valid.
	 * If an invalid argument is provided, an RtError (type = INVALID_USE)
	 * will be printed to the console. If a device is busy or otherwise 
	 * unavailable, the DeviceInfo member "probed" will have a value of "false" 
	 * and all other members are null. If the specified device is the
	 * current default input or output device, the corresponding
	 * "isDefault" member will have a value of "true".
	 * 
	 * @param	device	Any device integer between 0 and getDeviceCount() - 1.
	 * @return	DeviceInfo for a specified device number.</haxe_doc>
		</getDeviceInfo>
		<getDeviceCount public="1" set="method" line="91">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* A public function that queries for the number of audio devices available.
	 * 
	 * <p>This function performs a system query of available devices each time it
	 * is called, thus supporting devices connected after instantiation. If
	 * a system error occurs during processing, a warning will be issued.</p>
	 * 
	 * @return The number of audio devices available.]]></haxe_doc>
		</getDeviceCount>
		<getCurrentApi public="1" set="method" line="78">
			<f a=""><e path="rtAudio.Api"/></f>
			<haxe_doc>* @return The audio API specifier for the current instance of RtAudio.</haxe_doc>
		</getCurrentApi>
		<new public="1" set="method" line="71">
			<f a="?api">
				<e path="rtAudio.Api"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* The class constructor.
	 * 
	 * @param	?api	The compiled Api to be used. If no API argument is specified and multiple API support has been
	 * 					compiled, the default order of use is JACK, ALSA, OSS (Linux
	 * 					systems) and ASIO, DS (Windows systems).</haxe_doc>
		</new>
		<haxe_doc>* Copyright (c) 2011, Andy Li http://www.onthewings.net/
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * The name of the author may not be used to endorse or promote products derived 
 * from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE.</haxe_doc>
	</class>
	<typedef path="rtAudio.RtAudioCallback" params="" file="src/rtAudio/RtAudioCallback.hx">
		<f a="">
			<c path="rtAudio.RtAudio"/>
			<c path="Int"/>
		</f>
		<haxe_doc><![CDATA[* <p>All RtAudio clients must create a function of type RtAudioCallback
 * to read and/or write data from/to the audio stream.  When the
 * underlying audio system is ready for new input or output data, this
 * function will be invoked.</p>
 * 
 * <p>To continue normal stream operation, the RtAudioCallback function
 * should return a value of zero.  To stop the stream and drain the
 * output buffer, the function should return a value of one.  To abort
 * the stream immediately, the client should return a value of two.</p>]]></haxe_doc>
	</typedef>
	<enum path="rtAudio.RtAudioFormat" params="" file="src/rtAudio/RtAudioFormat.hx">
		<RTAUDIO_SINT8><haxe_doc>* 8-bit signed integer.</haxe_doc></RTAUDIO_SINT8>
		<RTAUDIO_SINT32><haxe_doc>* 32-bit signed integer.</haxe_doc></RTAUDIO_SINT32>
		<RTAUDIO_SINT24><haxe_doc>* Lower 3 bytes of 32-bit signed integer. Not supported in hxRtAudio.</haxe_doc></RTAUDIO_SINT24>
		<RTAUDIO_SINT16><haxe_doc>* 16-bit signed integer.</haxe_doc></RTAUDIO_SINT16>
		<RTAUDIO_FLOAT64><haxe_doc>* Normalized between plus/minus 1.0.</haxe_doc></RTAUDIO_FLOAT64>
		<RTAUDIO_FLOAT32><haxe_doc>* Normalized between plus/minus 1.0.</haxe_doc></RTAUDIO_FLOAT32>
		<haxe_doc><![CDATA[* RtAudio data format type.
 * 
 * <p>Support for signed integers and floats.  Audio data fed to/from an
 * RtAudio stream is assumed to ALWAYS be in host byte order.  The
 * internal routines will automatically take care of any necessary
 * byte-swapping between the host format and the soundcard.  Thus,
 * endian-ness is not a concern in the following format definitions.</p>]]></haxe_doc>
	</enum>
	<class path="rtAudio.RtAudioFormatValue" params="" file="src/rtAudio/RtAudioFormat.hx" module="rtAudio.RtAudioFormat">
		<RTAUDIO_SINT8 public="1" get="inline" set="null" line="75" static="1"><c path="Int"/></RTAUDIO_SINT8>
		<RTAUDIO_SINT16 public="1" get="inline" set="null" line="76" static="1"><c path="Int"/></RTAUDIO_SINT16>
		<RTAUDIO_SINT24 public="1" get="inline" set="null" line="77" static="1"><c path="Int"/></RTAUDIO_SINT24>
		<RTAUDIO_SINT32 public="1" get="inline" set="null" line="78" static="1"><c path="Int"/></RTAUDIO_SINT32>
		<RTAUDIO_FLOAT32 public="1" get="inline" set="null" line="79" static="1"><c path="Int"/></RTAUDIO_FLOAT32>
		<RTAUDIO_FLOAT64 public="1" get="inline" set="null" line="80" static="1"><c path="Int"/></RTAUDIO_FLOAT64>
		<haxe_doc>* These are the real value exist in the original rtAudio.</haxe_doc>
	</class>
	<enum path="rtAudio.RtAudioStreamFlags" params="" file="src/rtAudio/RtAudioStreamFlags.hx">
		<RTAUDIO_SCHEDULE_REALTIME><haxe_doc>* Try to select realtime scheduling for callback thread.</haxe_doc></RTAUDIO_SCHEDULE_REALTIME>
		<RTAUDIO_NONINTERLEAVED><haxe_doc>* Use non-interleaved buffers (default = interleaved).</haxe_doc></RTAUDIO_NONINTERLEAVED>
		<RTAUDIO_MINIMIZE_LATENCY><haxe_doc>* Attempt to set stream parameters for lowest possible latency.</haxe_doc></RTAUDIO_MINIMIZE_LATENCY>
		<RTAUDIO_HOG_DEVICE><haxe_doc>* Attempt grab device and prevent use by others.</haxe_doc></RTAUDIO_HOG_DEVICE>
		<haxe_doc>* Copyright (c) 2011, Andy Li http://www.onthewings.net/
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * The name of the author may not be used to endorse or promote products derived 
 * from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE 
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
 * OF THE POSSIBILITY OF SUCH DAMAGE.</haxe_doc>
	</enum>
	<class path="rtAudio.RtAudioStreamFlagsValue" params="" file="src/rtAudio/RtAudioStreamFlags.hx" module="rtAudio.RtAudioStreamFlags">
		<RTAUDIO_NONINTERLEAVED public="1" get="inline" set="null" line="58" static="1"><c path="Int"/></RTAUDIO_NONINTERLEAVED>
		<RTAUDIO_MINIMIZE_LATENCY public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></RTAUDIO_MINIMIZE_LATENCY>
		<RTAUDIO_HOG_DEVICE public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></RTAUDIO_HOG_DEVICE>
		<RTAUDIO_SCHEDULE_REALTIME public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></RTAUDIO_SCHEDULE_REALTIME>
		<haxe_doc>* These are the real value exist in the original rtAudio.</haxe_doc>
	</class>
	<typedef path="rtAudio.StreamOptions" params="" file="src/rtAudio/StreamOptions.hx">
		<a>
			<streamName>
				<c path="String"/>
				<haxe_doc>* It can be used to set the client name when using the Jack API.
	 * By default, the client name is set to RtApiJack. However, if you 
	 * wish to create multiple instances of RtAudio with Jack, each instance
	 * must have a unique client name.</haxe_doc>
			</streamName>
			<priority>
				<c path="Int"/>
				<haxe_doc>* If the RTAUDIO_SCHEDULE_REALTIME flag is set, RtAudio will attempt 
	 * to select realtime scheduling (round-robin) for the callback thread.
	 * The priority parameter will only be used if the RTAUDIO_SCHEDULE_REALTIME
	 * flag is set. It defines the thread's realtime priority.</haxe_doc>
			</priority>
			<numberOfBuffers>
				<c path="Int"/>
				<haxe_doc>* It can be used to control stream latency in the Windows DirectSound, 
	 * Linux OSS, and Linux Alsa APIs only.  A value of two is usually the
	 * smallest allowed.  Larger numbers can potentially result in more 
	 * robust stream performance, though likely at the cost of stream 
	 * latency.  The value set by the user is replaced during execution of 
	 * the openStream() function by the value actually used by the system.</haxe_doc>
			</numberOfBuffers>
			<flags><c path="Array"><e path="rtAudio.RtAudioStreamFlags"/></c></flags>
		</a>
		<haxe_doc><![CDATA[* The structure for specifying stream options.
 * 
 * <p>By default, RtAudio streams pass and receive audio data from the
 * client in an interleaved format.  By passing the
 * RTAUDIO_NONINTERLEAVED flag to the openStream() function, audio
 * data will instead be presented in non-interleaved buffers.  In
 * this case, each buffer argument in the RtAudioCallback function
 * will point to a single array of data, with nFrames samples for
 * each channel concatenated back-to-back.  For example, the first
 * sample of data for the second channel would be located at index 
 * nFrames (assuming the buffer pointer was recast to the correct
 * data type for the stream).</p>
 * 
 * <p>Certain audio APIs offer a number of parameters that influence the
 * I/O latency of a stream.  By default, RtAudio will attempt to set
 * these parameters internally for robust (glitch-free) performance
 * (though some APIs, like Windows Direct Sound, make this difficult).
 * By passing the RTAUDIO_MINIMIZE_LATENCY flag to the openStream()
 * function, internal stream settings will be influenced in an attempt
 * to minimize stream latency, though possibly at the expense of stream
 * performance.</p>
 *
 * <p>If the RTAUDIO_HOG_DEVICE flag is set, RtAudio will attempt to
 * open the input and/or output stream device(s) for exclusive use.
 * Note that this is not possible with all supported audio APIs.</p>
 * 
 * <p>If the RTAUDIO_SCHEDULE_REALTIME flag is set, RtAudio will attempt 
 * to select realtime scheduling (round-robin) for the callback thread.
 * The priority parameter will only be used if the RTAUDIO_SCHEDULE_REALTIME
 * flag is set. It defines the thread's realtime priority. </p>
 *]]></haxe_doc>
	</typedef>
	<typedef path="rtAudio.StreamParameters" params="" file="src/rtAudio/StreamParameters.hx">
		<a>
			<nChannels>
				<c path="Int"/>
				<haxe_doc>* Number of channels.</haxe_doc>
			</nChannels>
			<firstChannel>
				<c path="Int"/>
				<haxe_doc>* First channel index on device (default = 0).</haxe_doc>
			</firstChannel>
			<deviceId><c path="Int"/></deviceId>
		</a>
		<haxe_doc>* The structure for specifying input or ouput stream parameters.</haxe_doc>
	</typedef>
	<class path="rtAudio.tests.Testall" params="" file="src/rtAudio/tests/Testall.hx">
		<BASE_RATE get="inline" set="null" line="21" static="1"><c path="Float"/></BASE_RATE>
		<TIME get="inline" set="null" line="22" static="1"><c path="Float"/></TIME>
		<channels static="1"><c path="Int"/></channels>
		<usage set="method" line="25" static="1"><f a=""><e path="Void"/></f></usage>
		<sawi set="method" line="39" static="1"><f a="rt">
	<c path="rtAudio.RtAudio"/>
	<c path="Int"/>
</f></sawi>
		<sawni set="method" line="60" static="1"><f a="rt">
	<c path="rtAudio.RtAudio"/>
	<c path="Int"/>
</f></sawni>
		<inout set="method" line="82" static="1"><f a="rtAudio">
	<c path="rtAudio.RtAudio"/>
	<c path="Int"/>
</f></inout>
		<dac static="1"><c path="rtAudio.RtAudio"/></dac>
		<main public="1" set="method" line="99" static="1"><f a=""><e path="Void"/></f></main>
		<haxe_doc><![CDATA[* Ported from...
 * 
 * testall.cpp
 * by Gary P. Scavone, 2007-2008
 * 
 * <p>This program will make a variety of calls
 * to extensively test RtAudio functionality.</p>]]></haxe_doc>
	</class>
	<class path="sys.io.File" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="30" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveContent public="1" set="method" line="40" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></saveContent>
		<saveBytes public="1" set="method" line="46" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></saveBytes>
		<read public="1" set="method" line="52" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="56" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="60" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="64" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<file_contents line="72" static="1"><f a="">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></file_contents>
		<file_open line="73" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="77" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></file_eof>
		<file_read line="79" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="80" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="82" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="83" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="84" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_tell>
		<eof public="1" set="method" line="73"><f a=""><e path="Bool"/></f></eof>
		<tell public="1" set="method" line="68"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="64"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="59" override="1"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="48" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="37" override="1"><f a=""><c path="Int"/></f></readByte>
		<__f><d/></__f>
		<new set="method" line="33"><f a="f">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="62" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="63" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="64" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_tell>
		<file_flush line="66" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_flush>
		<file_write line="67" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="68" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<tell public="1" set="method" line="58"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="54"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="49" override="1"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="45" override="1"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="41" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="37" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<__f><d/></__f>
		<new set="method" line="33"><f a="f">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/lib/haxe/std/sys/io/FileSeek.hx">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
</haxe>